@page "/snake"
@using Microsoft.AspNetCore.Components;
@using SnakeGameBlazor.Data;
@using SnakeGameBlazor.Constants;
@using System.Linq;

<PageTitle>Snake</PageTitle>
<div class="containter" @onkeydown="ChangeDirection" tabindex="0">
    <div class="">
        
        <div class="row align-items-center">
            <div class="col-6">
                <table style="border-collapse: collapse; border-spacing: 0;">
                @for (int i = _gridSize; i > 0; i--)
                {
                    <tr>
                        @for (int j = 0; j < _gridSize; j++)
                        {
                            <td style="padding:0">
                                <img src=@("/images/"+ _cells.Find(c => c.x == j && c.y == i-1).Color) class="img-fluid m-0 p-0 g-0" style="margin: 0 auto;display:block;"/>
                            </td>
                        }
                    </tr>
                }
                </table>
            </div>
            
            <div class="col-6 text-center">
                <br />
                <h3>Level 1</h3>
                <br /><br />
                <h1 class="mb-0 fw-bold">SCORE</h1>
                <h1 class="mt-0 fw-bold">@_score</h1>
                <br /><br />
                <h3>Next level for:</h3>
                <h3>@(100 - _score)</h3>
            </div>
        </div>
    </div>
    <br /><br />
</div>

@code {
    private string _direction;
    private string _snakeHeadDirection;
    private int _gridSize = 13;
    private int _kebabFrequency = 10;
    private int _score;
    private int _movesCount;
    private int _kebabTimeLeft;
    private Cell _kebabCell = new Cell();
    private List<Cell> _cells = new List<Cell>();
    private bool _isRunning;
    private bool _turningEnabled = true;
    private Snake _snake = new Snake();
    private List<Cell> _edge = new List<Cell>();


    async Task PlaySnake()
    {
        _isRunning = true;

        while (_isRunning)
        {
            await Task.Delay(200);

            await NextAction();

            StateHasChanged();
        }
    }

    protected async override void OnInitialized()
    {
        await PreparePlayingBoard();
    }

    private async Task PreparePlayingBoard()
    {
        InitializeCells();
        await MakeCellsGreen();
        MakeEdgeBlack();
        InitializeSnake();
        SpawnFood(GridColors.Beer);
        _turningEnabled = true;
    }

    async Task NextAction()
    {
        MoveSnakeBody();

        MoveSnakeHead();

        CheckSnakeHeadPosition();

        if (_isRunning)
        {

            for (int i = 1; i < _snake.Length; i++)
            {
                _cells.Find(c => c.x == _snake.Cells[i].x && c.y == _snake.Cells[i].y).Color = GridColors.Blue;
            }

            ChangeSnakeHeadPicture();

            _movesCount++;
            DeleteKebabOrDecreaseKebabTimeLeft();
        }
    }

    private async void ChangeDirection(KeyboardEventArgs e)
    {
        if (_turningEnabled)
        {
            switch (e.Key)
            {
                case Directions.ArrowUp:
                    if (_snakeHeadDirection != Directions.Down || !_isRunning)
                    {
                        _direction = Directions.Up;
                    }
                    break;

                case Directions.ArrowDown:
                    if (_snakeHeadDirection != Directions.Up || !_isRunning)
                    {
                        _direction = Directions.Down;
                    }
                    break;

                case Directions.ArrowLeft:
                    if (_snakeHeadDirection != Directions.Right || !_isRunning)
                    {
                        _direction = Directions.Left;
                    }
                    break;

                case Directions.ArrowRight:
                    if (_snakeHeadDirection != Directions.Left || !_isRunning)
                    {
                        _direction = Directions.Right;
                    }
                    break;
            }

            if (!_isRunning)
                await PlaySnake();
        }

    }

    private void InitializeSnake()
    {
        if (_snake.Cells.Count != 0)
        {
            _snake.Cells.RemoveAll(c => c.x >= -1);
        }
        _snake.Length = 3;
        _snake.Head.x = Convert.ToInt32(Math.Round((double)(_gridSize / 2), mode: MidpointRounding.ToEven));
        _snake.Head.y = Convert.ToInt32(Math.Round((double)(_gridSize / 2), mode: MidpointRounding.ToEven));

        _snake.Tail.x = _snake.Head.x;
        _snake.Tail.y = _snake.Head.y;

        for (int i = 0; i < _snake.Length; i++)
        {
            _snake.Cells.Add(new Cell
            {
                x = _snake.Head.x,
                y = _snake.Head.y
            });

        }
        _cells.Find(c => c.x == _snake.Head.x && c.y == _snake.Head.y).Color = GridColors.EyesDown;
    }

    private async Task MakeCellsGreen()
    {
        var cells = _cells.Where(c => c.x >= 1 && c.y >= 1 && c.x <= _gridSize - 2 && c.y <= _gridSize - 2);
        foreach (var cell in cells)
        {
            cell.Color = GridColors.Green;
        }

    }

    private void InitializeCells()
    {
        if (_cells.Count > 0)
        {
            _cells.RemoveAll(c => c.x >= -1);
        }

        for (int i = 0; i < _gridSize; i++)
        {
            for (int j = 0; j < _gridSize; j++)
            {
                _cells.Add(new Cell
                    {
                        x = i,
                        y = j,
            });
            }
        }
    }

    private void MakeEdgeBlack()
    {
        var cells = _cells.Where(c => c.x == 0 || c.y == 0 || c.x == _gridSize-1 || c.y == _gridSize-1);
        foreach (var cell in cells)
        {
            cell.Color = GridColors.Black;
        }
    }

    private void MoveSnakeBody()
    {
        _snake.Tail.x = _snake.Cells[_snake.Length - 1].x;
        _snake.Tail.y = _snake.Cells[_snake.Length - 1].y;

        for (int i = _snake.Length - 1; i > 0; i--)
        {
            _snake.Cells[i].x = _snake.Cells[i - 1].x;
            _snake.Cells[i].y = _snake.Cells[i - 1].y;
        }
    }

    private void MoveSnakeHead()
    {
        switch (_direction)
        {
            case Directions.Up:
                _snake.Cells[0].y = _snake.Cells[0].y + 1;
                _snakeHeadDirection = Directions.Up;
                break;

            case Directions.Down:
                _snake.Cells[0].y = _snake.Cells[0].y - 1;
                _snakeHeadDirection = Directions.Down;
                break;

            case Directions.Left:
                _snake.Cells[0].x = _snake.Cells[0].x - 1;
                _snakeHeadDirection = Directions.Left;
                break;

            case Directions.Right:
                _snake.Cells[0].x = _snake.Cells[0].x + 1;
                _snakeHeadDirection = Directions.Right;
                break;
        }
        _snake.Head.x = _snake.Cells[0].x;
        _snake.Head.y = _snake.Cells[0].y;

    }

    private async void CheckSnakeHeadPosition()
    {
        switch (_cells.Find(c => c.x == _snake.Head.x && c.y == _snake.Head.y).Color)
        {
            case GridColors.Blue:
            case GridColors.Black:
            case GridColors.EyesDown:
            case GridColors.EyesUp:
            case GridColors.EyesLeft:
            case GridColors.EyesRight:
                GameOver();
                break;

            case GridColors.Beer:
                MakeSnakeLonger();

                if (_score>=5)
                {
                    WinLevel();
                }
                else if (_score%_kebabFrequency == 0)
                {
                    SpawnFood(GridColors.Kebab);
                    _kebabTimeLeft = 2*_gridSize;
                }
                SpawnFood(GridColors.Beer);
                break;

            case GridColors.Kebab:
                _score += 10;
                _cells.Find(c => c.x == _snake.Tail.x && c.y == _snake.Tail.y).Color = GridColors.Green;
                break;

            case GridColors.Green:
                _cells.Find(c => c.x == _snake.Tail.x && c.y == _snake.Tail.y).Color = GridColors.Green;
                break;
        }
    }

    private void SpawnFood(string foodName)
    {
        var generator = new Random();
        var foodCell = new Cell
            {
                x = generator.Next(1, _gridSize-2),
                y = generator.Next(1, _gridSize-2)
            };
        while (_snake.Cells.Any(snakeCell => snakeCell.x == foodCell.x && snakeCell.y == foodCell.y) || _cells.Find(c => c.x == foodCell.x && c.y == foodCell.y).Color == GridColors.Beer)
        {
            foodCell.x = generator.Next(1, _gridSize - 2);
            foodCell.y = generator.Next(1, _gridSize - 2);
        }

        _cells.Find(c => c.x == foodCell.x && c.y == foodCell.y).Color = foodName;

        if (foodName == GridColors.Kebab)
        {
            _kebabCell.x = foodCell.x;
            _kebabCell.y = foodCell.y;
        }
    }

    private void MakeSnakeLonger()
    {
        _snake.Cells.Add(new Cell
            {
                x = _snake.Tail.x,
                y = _snake.Tail.y
            });
        _snake.Length++;
        _score++;
    }


    private async void GameOver()
    {
        _isRunning = false;
        _turningEnabled = false;
        await FlashSnake();
        PreparePlayingBoard();
        StateHasChanged();
        _score = 0;
        _turningEnabled = true;
    }

    private async Task FlashSnake()
    {
        for (int i = 0; i < 4; i++)
        {
            ChangeSnakeColor(GridColors.Red);
            StateHasChanged();
            await Task.Delay(150);

            ChangeSnakeColor(GridColors.Blue);
            StateHasChanged();
            await Task.Delay(150);
        }
    }

    private void ChangeSnakeColor(string color)
    {
        foreach (var cell in _snake.Cells)
        {
            _cells.Find(c => c.x == cell.x && c.y == cell.y).Color =color;
        }
        _cells.Find(c => c.x == _snake.Tail.x && c.y == _snake.Tail.y).Color = color;
    }

    private void DeleteKebabOrDecreaseKebabTimeLeft()
    {
        if (_cells.Any(c => c.Color == GridColors.Kebab))
        {
            if (_kebabTimeLeft > 0)
            {
                _kebabTimeLeft--;
            }else
            {
                _cells.Find(c => c.x == _kebabCell.x && c.y == _kebabCell.y).Color = GridColors.Green;
            }
        }
    }

    private void ChangeSnakeHeadPicture()
    {
        switch (_snakeHeadDirection)
        {
            case Directions.Up:
                _cells.Find(c => c.x == _snake.Head.x && c.y == _snake.Head.y).Color = GridColors.EyesUp;
                break;

            case Directions.Down:
                _cells.Find(c => c.x == _snake.Head.x && c.y == _snake.Head.y).Color = GridColors.EyesDown;

                break;

            case Directions.Left:
                _cells.Find(c => c.x == _snake.Head.x && c.y == _snake.Head.y).Color = GridColors.EyesLeft;
                break;

            case Directions.Right:
                _cells.Find(c => c.x == _snake.Head.x && c.y == _snake.Head.y).Color = GridColors.EyesRight;
                break;
        }
    }

    private async Task WinLevel()
    {
        _isRunning = false;
        _turningEnabled = false;
        await SnakeGoingIntoHoleAnimation();

        for (int i = 0; i < 3; i++)
        {
            await MakeCellsGreen();
            StateHasChanged();
            await WriteCongrats();
            StateHasChanged();
        }

        await Task.Delay(1000);
        await CountdownAnimation();
        PreparePlayingBoard();
    }

    private async Task SnakeGoingIntoHoleAnimation()
    {
        _cells.Find(c => c.x == _snake.Head.x && c.y == _snake.Head.y).Color = GridColors.Hole;
        switch (_snakeHeadDirection)
        {
            case Directions.Up:
                _cells.Find(c => c.x == _snake.Cells[1].x && c.y == _snake.Cells[1].y).Color = GridColors.EyesUp;
                break;

            case Directions.Down:
                _cells.Find(c => c.x == _snake.Cells[1].x && c.y == _snake.Cells[1].y).Color = GridColors.EyesDown;
                break;

            case Directions.Left:
                _cells.Find(c => c.x == _snake.Cells[1].x && c.y == _snake.Cells[1].y).Color = GridColors.EyesLeft;
                break;

            case Directions.Right:
                _cells.Find(c => c.x == _snake.Cells[1].x && c.y == _snake.Cells[1].y).Color = GridColors.EyesRight;
                break;
        }
        StateHasChanged();
        await Task.Delay(2000);

        _cells.Find(c => c.x == _snake.Cells[1].x && c.y == _snake.Cells[1].y).Color = GridColors.Blue;
        for (int i = _snake.Length-1; i >0 ; i--)
        {
            _cells.Find(c => c.x == _snake.Cells[i].x && c.y == _snake.Cells[i].y).Color = GridColors.Green;
            StateHasChanged();
            await Task.Delay(100);
        }
    }

    private async Task WriteCongrats()
    {
        var middle = new Cell(){
            x = Convert.ToInt32(Math.Round((double)(_gridSize / 2), mode: MidpointRounding.ToNegativeInfinity)),
            y = Convert.ToInt32(Math.Round((double)(_gridSize / 2), mode: MidpointRounding.ToNegativeInfinity))
        };
        string inscription = "CONGRATS";

        for (int i = -4, j=0; i < 4; i++, j++)
        {
            _cells.Find(c => c.x == middle.x + i && c.y == middle.y+4).Color = inscription[j].ToString() + ".png";
            StateHasChanged();
            await Task.Delay(80);
        }
        _cells.Find(c => c.x == middle.x + 4 && c.y == middle.y + 4).Color = Letters.ExclamationMark;
        StateHasChanged();
        await Task.Delay(150);

    }

    private async Task CountdownAnimation()
    {
        var middle = new Cell(){
            x = Convert.ToInt32(Math.Round((double)(_gridSize / 2), mode: MidpointRounding.ToNegativeInfinity)),
            y = Convert.ToInt32(Math.Round((double)(_gridSize / 2), mode: MidpointRounding.ToNegativeInfinity))
        };

        string inscription = "LEVEL";

        for (int i = -5, j = 0; i < 0; i++, j++)
        {
            _cells.Find(c => c.x == middle.x + i && c.y == middle.y + 2).Color = inscription[j].ToString() + ".png";
        }
        _cells.Find(c => c.x == middle.x + 1 && c.y == middle.y + 2).Color = "2.png";

        inscription = "FOR";

        for (int i = 3, j = 0; i < 6; i++, j++)
        {
            _cells.Find(c => c.x == middle.x + i && c.y == middle.y + 2).Color = inscription[j].ToString() + ".png";
        }

        StateHasChanged();
        await Task.Delay(2000);

        var cellsToChange = new List<Cell>()
        {
            new Cell {x = middle.x, y = middle.y-2, Color = GridColors.Yellow},
            new Cell {x = middle.x, y = middle.y, Color = GridColors.Yellow},
            new Cell {x = middle.x, y = middle.y-4, Color = GridColors.Yellow},
            new Cell {x = middle.x-1, y = middle.y, Color = GridColors.Yellow},
            new Cell {x = middle.x-1, y = middle.y-4, Color = GridColors.Yellow},
            new Cell {x = middle.x+1, y = middle.y-2, Color = GridColors.Yellow},
            new Cell {x = middle.x+1, y = middle.y-1, Color = GridColors.Yellow},
            new Cell {x = middle.x+1, y = middle.y , Color = GridColors.Yellow},
            new Cell {x = middle.x+1, y = middle.y-3, Color = GridColors.Yellow},
            new Cell {x = middle.x+1, y = middle.y-4, Color = GridColors.Yellow}
        };

        foreach (var cell in cellsToChange)
        {
            _cells.Find(c => c.x == cell.x && c.y == cell.y).Color = cell.Color;
        }

        StateHasChanged();
        await Task.Delay(1000);
        cellsToChange.RemoveAll(c => c.x >= -1);

        cellsToChange.AddRange(new List<Cell>()
        {
            new Cell {x = middle.x, y = middle.y-2, Color = GridColors.Yellow},
            new Cell {x = middle.x, y = middle.y, Color = GridColors.Yellow},
            new Cell {x = middle.x, y = middle.y-4, Color = GridColors.Yellow},
            new Cell {x = middle.x-1, y = middle.y, Color = GridColors.Yellow},
            new Cell {x = middle.x-1, y = middle.y-4, Color = GridColors.Yellow},
            new Cell {x = middle.x+1, y = middle.y-2, Color = GridColors.Yellow},
            new Cell {x = middle.x+1, y = middle.y-1, Color = GridColors.Yellow},
            new Cell {x = middle.x+1, y = middle.y, Color = GridColors.Yellow},
            new Cell {x = middle.x+1, y = middle.y-4, Color = GridColors.Yellow},
            new Cell {x = middle.x-1, y = middle.y-2, Color = GridColors.Yellow},
            new Cell {x = middle.x-1, y = middle.y-3, Color = GridColors.Yellow},
            new Cell {x = middle.x+1, y = middle.y-3, Color = GridColors.Green},
        });

        foreach (var cell in cellsToChange)
        {
            _cells.Find(c => c.x == cell.x && c.y == cell.y).Color = cell.Color;
        }
        StateHasChanged();
        await Task.Delay(1000);
        cellsToChange.RemoveAll(c => c.x >= -1);

        cellsToChange.AddRange(new List<Cell>()
        {
            new Cell {x = middle.x-1, y = middle.y, Color = GridColors.Green},
            new Cell {x = middle.x, y = middle.y, Color = GridColors.Green},
            new Cell {x = middle.x-1, y = middle.y-2, Color = GridColors.Green},
            new Cell {x = middle.x, y = middle.y-2, Color = GridColors.Green},
            new Cell {x = middle.x-1, y = middle.y-2, Color = GridColors.Green},
            new Cell {x = middle.x-1, y = middle.y-3, Color = GridColors.Green},
            new Cell {x = middle.x-1, y = middle.y-4, Color = GridColors.Green},
            new Cell {x = middle.x, y = middle.y-4, Color = GridColors.Green},
            new Cell {x = middle.x+1, y = middle.y-3, Color = GridColors.Yellow},
            
        });

        foreach (var cell in cellsToChange)
        {
            _cells.Find(c => c.x == cell.x && c.y == cell.y).Color = cell.Color;
        }

        StateHasChanged();
        await Task.Delay(1000);

        MakeCellsGreen();
        StateHasChanged();
    }
}
